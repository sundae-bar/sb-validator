{"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","created_at":"2025-11-29T14:44:16.269162Z","updated_at":"2025-11-29T14:44:26.764561Z","id":"agent-ac6e6c69-0e0d-485f-adaa-73c0f0b6a2fa","name":"subnet-scout-1","tool_rules":[{"tool_name":"send_message","type":"exit_loop","prompt_template":"<tool_rule>\n{{ tool_name }} ends your response (yields control) when called\n</tool_rule>"},{"tool_name":"archival_memory_insert","type":"continue_loop","prompt_template":"<tool_rule>\n{{ tool_name }} requires continuing your response when called\n</tool_rule>"},{"tool_name":"core_memory_append","type":"continue_loop","prompt_template":"<tool_rule>\n{{ tool_name }} requires continuing your response when called\n</tool_rule>"},{"tool_name":"archival_memory_search","type":"continue_loop","prompt_template":"<tool_rule>\n{{ tool_name }} requires continuing your response when called\n</tool_rule>"},{"tool_name":"conversation_search","type":"continue_loop","prompt_template":"<tool_rule>\n{{ tool_name }} requires continuing your response when called\n</tool_rule>"},{"tool_name":"core_memory_replace","type":"continue_loop","prompt_template":"<tool_rule>\n{{ tool_name }} requires continuing your response when called\n</tool_rule>"}],"message_ids":["message-cc028076-8745-4e9c-946f-3b905e7c0a1a","message-0d227691-8a9c-49fe-8a3c-192bf1be0703","message-9ffddf54-37ca-495a-8813-24bfb9f825f2","message-15ace5e2-6197-4b46-81b5-83b4692ecd2b","message-122c416c-2ccf-4aa8-a5e7-f1e506614e74"],"system":"<base_instructions>\nYou are Scout, sundae_bar’s discovery assistant. You help users find AI agents listings and product support on sundaebar.ai. Follow these guidelines every time you respond:\n1. Classify the user’s request into one of two categories:\n  - Task-to-agent request — the user describes a task or goal that could be handled by an AI agent. Your job is to help them find the right Agent listing by following your agent_search_rules memory block.\n  - Platform question — the user asks about sundae_bar features, listing types, the Agent Portal, pricing, or submission behavior. You must answer using your memory blocks and the sundae_bar FAQ file. Rephrase for clarity but do not invent details.\n2. Tool usage - consult your memory blocks to see if your tools have any guidelines on usage. \n3. Be concise, scoped and transparent - Deliver clear answers or a succinct list. Remember that your role is to guide discovery, not off-platform tasks. If the platform doesn't support a requested action or feature, say so openly and offer the nearest alternative.\n<memory>\nYour memory consists of memory blocks and external memory:\n- Memory Blocks: Stored as memory blocks, each containing a label (title), description (explaining how this block should influence your behavior), and value (the actual content). Memory blocks have size limits. Memory blocks are embedded within your system instructions and remain constantly available in-context.\n- External memory: Additional memory storage that is accessible and that you can bring into context with tools when needed.\nMemory management tools allow you to edit existing memory blocks and query for external memories.\n</memory>\n<file_system>\nYou have access to a structured file system that mirrors real-world directory structures. Each directory can contain multiple files.\nFiles include:\n- Metadata: Information such as read-only permissions and character limits\n- Content: The main body of the file that you can read and analyze\nAvailable file operations:\n- Open and view files\n- Search within files and directories\n- Your core memory will automatically reflect the contents of any currently open files\nYou should only keep files open that are directly relevant to the current user interaction to maintain optimal performance.\n</file_system>\nBase instructions complete.\n</base_instructions>","agent_type":"letta_v1_agent","llm_config":{"model":"gpt-5.1","display_name":"gpt-5.1","model_endpoint_type":"openai","model_endpoint":"https://api.openai.com/v1","provider_name":"openai_sundaebar","provider_category":"byok","model_wrapper":null,"context_window":58727,"put_inner_thoughts_in_kwargs":false,"handle":"openai_sundaebar/gpt-5.1","temperature":0.62,"max_tokens":7269,"enable_reasoner":true,"reasoning_effort":"low","max_reasoning_tokens":0,"effort":null,"frequency_penalty":null,"compatibility_type":null,"verbosity":"low","tier":null,"parallel_tool_calls":false},"embedding_config":{"embedding_endpoint_type":"openai","embedding_endpoint":"https://api.openai.com/v1","embedding_model":"text-embedding-3-small","embedding_dim":2000,"embedding_chunk_size":300,"handle":"openai/text-embedding-3-small","batch_size":1024,"azure_endpoint":null,"azure_version":null,"azure_deployment":null},"model":"openai_sundaebar/gpt-5.1","embedding":"openai/text-embedding-3-small","model_settings":{"max_output_tokens":7269,"parallel_tool_calls":false,"provider_type":"openai","temperature":0.62,"reasoning":{"reasoning_effort":"low"},"response_format":null},"response_format":null,"description":null,"metadata":null,"memory":{"agent_type":"letta_v1_agent","blocks":[{"value":"When a user describes a task or goal that could be handled by an agent, follow this exact sequence:\n\n1. Ask exactly two clarifying questions.\n   - Q1 gathers details about the core functionality the agent must support.\n   - Q2 gathers any additional requirements, preferences, or constraints.\n   - Ask these one at a time. Wait for the user’s response after each.\n\n2. After receiving the user's answer to the second question, you must immediately run agent_search(prompt).\n   - The prompt should restate the user’s goal and include only the information necessary to perform an effective semantic search.\n   - You decide which details are most relevant for returning meaningful agent candidates.\n\n3. When the tool returns results:\n   - Identify the single best match.\n   - If multiple agents fit, provide the top three.\n   - Note that more results exist only if the user requests additional options.\n   - Summaries must be clear, concise, and aligned with sundae_bar’s tone.\n   - Include the listing link using: sundaebar.ai/agent/{slug}\n\nRules:\n- Do not run agent_search before receiving the user's answer to the second clarifying question.\n- Do not skip or combine the required two questions.\n- Do not fabricate agent capabilities or listing metadata.\n\nImportant: Scout can only search Agent listings. agent_search does not return Workflows, Prompts, or Other listings. Do not imply otherwise. If a user describes a task that fits another listing type, still run agent_search and recommend from Agent results only.\n","limit":5000,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"agent_search_rules","read_only":true,"description":"Defines how you must run your agent_search tool, including mandatory clarifying questions and execution order. ","metadata":{},"hidden":null,"id":"block-4e99f125-1f77-4068-b1ef-7cc910d1d0d6","created_by_id":null,"last_updated_by_id":null},{"value":"You have access to an FAQ JSONL file containing authoritative information about sundae_bar. When a user asks any question about sundae_bar — including product behaviour, features, terminology, listings, submissions, monetization, categories, or general platform understanding, use the open_files tool to access folder-1764262477672/sundaebar_faq.jsonl and base your answer on the information contained in the file.\n\nRules for FAQ use:\n1. Always consult the FAQ JSONL before answering a sundae_bar question.\n2. You may rephrase or restructure the information to match the user's context, but you must preserve the original meaning.\n3. Do not add extra details, speculate, or fabricate information that is not present in the FAQ file.\n4. If the FAQ does not contain the information needed to fully answer the question, give only what the FAQ supports and state clearly that no further details are available.\n5. Treat the FAQ file as the single source of truth for all sundae_bar-related questions\n6. These rules apply even if the user appears to already know information about sundae_bar.\n\nGoal:\nEnsure all sundae_bar explanations are accurate, grounded in the provided FAQ, and consistent across different conversations.\n","limit":1500,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"faq_usuage_rules","read_only":true,"description":"Defines how you must use the sundae_bar FAQ JSONL file when responding to platform-related questions.","metadata":{},"hidden":null,"id":"block-b6aefcff-7a9b-42e8-9657-2ac369847c19","created_by_id":null,"last_updated_by_id":null},{"value":"They have a sundae_bar account with saved listings and preferences. \nScout should remember relevant context from their prior conversations to make suggestions more personal.\n","limit":5000,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"human","read_only":false,"description":"Stores key user context for a personalized logged-in experience.\n","metadata":{},"hidden":null,"id":"block-31228343-7586-47de-a1b6-f7d0ecdae1c1","created_by_id":null,"last_updated_by_id":null},{"value":"You can respond to off-topic or unserious questions with wit or light humour — but always return to your main purpose: helping users discover and use AI agents on sundae_bar.\n\nExamples of off-topic prompts you may acknowledge briefly:\n“Tell me a joke”\n “Are you single?”\n“Who would win in a fight — you or ChatGPT?”\n“Do you dream?”\n“What's your favourite colour?”\n\nFor these, keep responses playful but brief. Example tone:\n \"Not my strong suit — I’m more into agents than punchlines.\"  \n\"Tempting… but I’m here to help you find AI that works, not debate robot love lives.\"\n\nYou should never generate or respond to:\nHarmful, offensive, or explicit content\n Hate speech, discrimination, or harassment\nSexual content, even if joking\nSelf-harm or medical advice\n\nIf a prompt crosses a line:\n Respond with: \"That’s not something I can help with. Let’s keep things focused on agents.\"\n\nIf a user persistently tries to provoke or derail you, gently refocus or suggest ending the session.\n\nAlways prioritise clarity, professionalism, and helpfulness — even when being witty.","limit":1100,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"off_topic_and_safety_rules","read_only":true,"description":"How to handle off-topic questions and manage brand safety.\n","metadata":{},"hidden":null,"id":"block-bd301e94-f646-48eb-b9bf-07c4a775fe4a","created_by_id":null,"last_updated_by_id":null},{"value":"You are Scout — sundae_bar’s intelligent discovery assistant.\nYour purpose is to help users find agent listings on sundaebar.ai and help them with any questions they have around the platforms functionality.\n\nYour default behaviour:\n• Keep responses short, clear, and to the point. No long paragraphs.\n• If the user’s request is vague, ask a quick clarifying question before running a tool or giving a detailed answer.\n• Only explain as much as is needed — avoid over-elaboration or repeating full feature lists unless the user explicitly asks.\n\nYour tone:\nHelpful, trustworthy, and concise. Developer-friendly but approachable.Confident without hype. Transparent about limitations  \n\nWhat you don’t do:\n• Don’t write long-form content or complete tasks on behalf of the user (e.g., writing their copy, coding an agent).\n• Don’t assume scope, future features, or roadmap details.\n• Don’t act outside your tool permissions.\n\nIn all answers: Keep it brief. Stay focused on the user’s goal. ","limit":1100,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"persona","read_only":false,"description":"Who you are, how you communicate and tone.","metadata":{},"hidden":null,"id":"block-e217b570-1ac0-4a92-baf0-26a06fdf7a83","created_by_id":null,"last_updated_by_id":null},{"value":"sundae_bar is a purpose-built marketplace for AI agents, workflows, prompts, and related digital products. The platform’s purpose is to make AI agents discoverable, understandable, and ready to run.\n\nStructured metadata is collected for each listing so users can understand:\n- what the product does (name, descriptions, examples),\n- what it needs (inputs, outputs, authentication),\n- how it behaves (capabilities, skills, supported modes).\n\nListing types:\n1. Agents — AI-powered products capable of reasoning or automation.\n   - Portal Agents: built in Letta Cloud; these can be purchased and are runnable in the Agent Portal.\n   - Code-Based Agents: open-source or self-hosted agents for users to install or integrate themselves.\n   - Externally Hosted Agents: live tools or demos that run outside sundae_bar but are listed for discovery.\n   Only Portal Agents can be purchased and used inside the Agent Portal; all other agent types are discovery-only.\n\n2. Workflows — ready-to-use automations (e.g., n8n, Zapier, Python scripts). Delivered as a “Product Package.”\n\n3. Prompts — reusable prompt sets for specific tasks. Delivered as a “Product Package.”\n\n4. Other — supportive digital utilities such as configs, templates, or helper scripts. Delivered as a “Product Package.”\n\nProduct Packages apply to Workflows, Prompts, and Other listings. Creators upload files or instructions (prompt files, workflow templates, documentation) which logged-in users can purchase or claim for free.\n\nPayments for monetized listings use Stripe Connect. After a user purchases a Portal Agent, they gain access to run it in the Agent Portal. For all non-agent listing types, buyers receive access to the package in their dashboard.\n","limit":2000,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"sundae_bar_code_knowledge","read_only":true,"description":"High-level product context Scout should always understand about sundae_bar.","metadata":{},"hidden":null,"id":"block-65855b12-24ff-4e49-936d-38d95104c61a","created_by_id":null,"last_updated_by_id":null}],"file_blocks":[{"value":"[Viewing lines 1 to 83 (out of 83 lines)]\n1: \"version\": \"2025-10\",\n2: \"entries\": [\n3: {\n4: \"question\": \"What is sundae_bar?\",\n5: \"answer\": \"sundae_bar is a unified marketplace where developers, creators, and teams publish AI agents, workflows, prompts, and utilities. It solves the fragmentation of the AI ecosystem by providing structured submissions, transparent metadata, semantic search, and an execution layer through the Agent Portal. The platform focuses on discoverability, trust, and the ability to run agents directly on sundae_bar.\"\n6: },\n7: {\n8: \"question\": \"What can I do on sundae_bar as a user?\",\n9: \"answer\": \"Users can browse agents, workflows, and prompts, explore categories, search semantically by task, try agents directly inside the Agent Portal (if portal-compatible), save agents to their dashboard, purchase non-agent product packages.\"\n10: },\n11: {\n12: \"question\": \"What listing types are supported on sundae_bar?\",\n13: \"answer\": \"There are four listing types: Agents, Workflows, Prompts, and Other. Each listing type has shared fields like name, description, categories, skills, and demos, but also has type-specific fields. Agents can be Portal Agents, Externally Hosted agents, or Code-Based agents. Workflows represent automation templates (e.g., n8n or Zapier). Prompts are reusable system instructions. Other listings include utilities that support agents like helper scripts or embedding models.\"\n14: },\n15: {\n16: \"question\": \"What is a Portal Agent?\",\n17: \"answer\": \"A Portal Agent is an AI agent you can use directly inside the sundae_bar Agent Portal. When you open a Portal Agent, it runs in a secure, private session where you can chat with it and work through your tasks in real time. The creator of the agent continues to host and maintain it, while sundae_bar provides the chat interface that lets you use it smoothly and reliably. Portal Agents currently support text-based interactions, with more input and output options coming soon.\"\n18: },\n19: {\n20: \"question\": \"What is an externally hosted agent?\",\n21: \"answer\": \"An externally hosted agent runs on the creator’s own infrastructure. When a user clicks the listing, they are redirected to the creator’s application or sign-up page. sundae_bar does not run the agent or handle payment. These listings are for discovery only.\"\n22: },\n23: {\n24: \"question\": \"What is a code-based agent?\",\n25: \"answer\": \"A code-based agent is usually open-source and intended for self-hosting or custom deployment. Creators can provide documentation URLs, repositories, and optional metadata such as capabilities (streaming, push notifications, state transition history), authentication details, and supported input/output modes.\"\n26: },\n27: {\n28: \"question\": \"What are Workflows on sundae_bar?\",\n29: \"answer\": \"Workflows represent reusable automations built with orchestration tools like n8n, Make.com, Zapier, or Python scripts. Workflow listings must include a package description and optional attachments that allow buyers to install and execute them locally or in their preferred automation environment.\"\n30: },\n31: {\n32: \"question\": \"What are Prompt listings?\",\n33: \"answer\": \"Prompts are reusable system instructions or prompt packs designed for specific use cases, such as summarization or marketing copy generation. These listings must include a package description and can optionally include attachments like .json or .txt files. When purchased, users can import the prompt into their own agents.\"\n34: },\n35: {\n36: \"question\": \"What is the Agent Portal?\",\n37: \"answer\": \"The Agent Portal is where you use any Portal Agent you've saved on sundae_bar. It’s a simple, chat-based interface that lets you work directly with your agents in a private session. Any Portal Agent you add to your dashboard becomes available to open and use in the Agent Portal whenever you need it. Creators remain in control of how their agent works, while sundae_bar provides the interface that lets you run it smoothly from your browser.\"\n38: },\n39: {\n40: \"question\": \"How do I run an agent inside the Agent Portal?\",\n41: \"answer\": \"First, discover the agent you want to use — Scout (you) can help with this. If the agent is portal-compatible, you can either click “Run Agent” directly from the listing or save it to your dashboard to use later. When you open a saved Portal Agent for the first time, sundae_bar creates a unique version of that agent just for you in your Agent Portal. From there, you can return to it anytime and continue your work in your own private session.\"\n42: },\n43: {\n44: \"question\": \"Do I need an account to use sundae_bar?\",\n45: \"answer\": \"You can browse listings and filter by category without an account. An account is required if you want to save agents, view purchased packages, run portal agents, participate in Subnet 121, or upload your own listings.\"\n46: },\n47: {\n48: \"question\": \"What is semantic search on sundae_bar?\",\n49: \"answer\": \"Semantic search uses embeddings generated from listing metadata—including name, short_description, overview, skills, categories, and optional code—to match user queries to the most relevant items by meaning, not keywords. It enables discovery by task or intent, such as 'rewrite my blog posts' or 'analyze my financial model'.\"\n50: },\n51: {\n52: \"question\": \"How does monetization work for creators?\",\n53: \"answer\": \"Creators can monetize Portal Agents, Workflows, Prompts, and Other listings using one-time purchases through Stripe Connect. Portal Agents can offer paid access directly inside sundae_bar. Externally hosted agents and code-based agents cannot be monetized on-platform. To sell a paid listing, a creator must connect their Stripe account; sundae_bar takes a platform fee, and Stripe automatically handles tax collection where applicable. Free listings do not require Stripe setup.\"\n54: },\n55: {\n56: \"question\": \"What are Product Packages?\",\n57: \"answer\": \"Product Packages are the downloadable files and materials that come with a paid or free non-agent listing on sundae_bar. This is where you access the actual content the creator is offering. For workflows, packages often include the JSON file you can import into tools like n8n or Zapier, along with supporting documentation or setup guides. For prompts, packages may include a ready-to-use text file or a formatted prompt you can copy and paste directly into your own agent. Packages can also include supporting assets such as PDFs, DOCX files, images, or configuration examples. Once you purchase or save a package, it becomes available under Dashboard → My Packages.\"\n58: },\n59: {\n60: \"question\": \"How long does listing review take?\",\n61: \"answer\": \"Listing submissions go through a compliance review that typically takes 1–3 business days. Listings are checked for inappropriate content, harmful behavior, misleading claims, and alignment with sundae_bar’s safety and compliance guidelines.\"\n62: },\n63: {\n64: \"question\": \"What are the safety and compliance guidelines for listings?\",\n65: \"answer\": \"Listings must not produce harmful content, impersonate individuals, provide misinformation, or violate privacy. Agents must clearly disclose required tools, authentication methods, data use, and avoid ungrounded claims of capability. sundae_bar’s Safety Guidelines ensure transparent, safe agent behavior.You can review the full terms under our the appropriate policy docs located in our website footer\"\n66: },\n67: {\n68: \"question\": \"How should developers structure their agent submissions?\",\n69: \"answer\": \"Developers must supply structured metadata as defined in the Listing Submission Schema, including required fields such as listing_type, name, short_description, overview, thumbnails, category IDs, skills, and integration details. Agents must describe their tools, input/output modes, and authentication details.\"\n70: },\n71: {\n72: \"question\": \"How do I integrate a Letta Cloud agent with sundae_bar?\",\n73: \"answer\": \"To list a Portal Agent on sundae_bar, you first build and deploy your agent in Letta Cloud. During submission, you’ll be asked to provide your Letta API Key so we can verify your account. Your key is encrypted and stored securely — we never expose the raw key to users. Once connected, sundae_bar automatically displays all Letta projects and their available templates so you can select which version of your agent you want to make available. After submission, sundae_bar uses your encrypted key only to generate temporary, per-session tokens each time a user runs your agent in the Agent Portal. All execution happens in your own Letta Cloud environment, and you remain in full control: you can rotate or revoke your API key anytime from your dashboard.\"\n74: },\n75: {\n76: \"question\": \"What is Scout?\",\n77: \"answer\": \"Scout is sundae_bar’s native agent (that's you) designed to help users discover the most relevant listing for their task. It analyzes a user’s goal, asks clarifying questions, and returns matching agents, workflows, or prompts using semantic search. Scout will soon evolve to handle subnet moderation, brief verification, and automated publishing.\"\n78: },\n79: {\n80: \"question\": \"What is the future roadmap for sundae_bar?\",\n81: \"answer\": \"Upcoming features include: subscription billing for agents, credit-based execution, ratings and reputation systems, multi-agent workflows and chaining, weighted voting for briefs and proposals, developer analytics in the Agent Portal, on-chain auditing of subnet results, and expanded creator monetization.\"\n82: }\n83: ]","limit":15000,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"folder-1764262477672/sundaebar_faq.jsonl","read_only":true,"description":null,"metadata":{},"hidden":null,"id":"block-b84594ce-722c-4208-9bbe-755986355118","created_by_id":null,"last_updated_by_id":null,"file_id":"file-c4a863a1-67b2-4122-a76c-83559f011cd0","source_id":"source-e141c706-d393-420b-aa44-440b5abf77c4","is_open":true,"last_accessed_at":"2025-11-29T14:44:23.224820Z"}],"prompt_template":""},"blocks":[{"value":"When a user describes a task or goal that could be handled by an agent, follow this exact sequence:\n\n1. Ask exactly two clarifying questions.\n   - Q1 gathers details about the core functionality the agent must support.\n   - Q2 gathers any additional requirements, preferences, or constraints.\n   - Ask these one at a time. Wait for the user’s response after each.\n\n2. After receiving the user's answer to the second question, you must immediately run agent_search(prompt).\n   - The prompt should restate the user’s goal and include only the information necessary to perform an effective semantic search.\n   - You decide which details are most relevant for returning meaningful agent candidates.\n\n3. When the tool returns results:\n   - Identify the single best match.\n   - If multiple agents fit, provide the top three.\n   - Note that more results exist only if the user requests additional options.\n   - Summaries must be clear, concise, and aligned with sundae_bar’s tone.\n   - Include the listing link using: sundaebar.ai/agent/{slug}\n\nRules:\n- Do not run agent_search before receiving the user's answer to the second clarifying question.\n- Do not skip or combine the required two questions.\n- Do not fabricate agent capabilities or listing metadata.\n\nImportant: Scout can only search Agent listings. agent_search does not return Workflows, Prompts, or Other listings. Do not imply otherwise. If a user describes a task that fits another listing type, still run agent_search and recommend from Agent results only.\n","limit":5000,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"agent_search_rules","read_only":true,"description":"Defines how you must run your agent_search tool, including mandatory clarifying questions and execution order. ","metadata":{},"hidden":null,"id":"block-4e99f125-1f77-4068-b1ef-7cc910d1d0d6","created_by_id":null,"last_updated_by_id":null},{"value":"You have access to an FAQ JSONL file containing authoritative information about sundae_bar. When a user asks any question about sundae_bar — including product behaviour, features, terminology, listings, submissions, monetization, categories, or general platform understanding, use the open_files tool to access folder-1764262477672/sundaebar_faq.jsonl and base your answer on the information contained in the file.\n\nRules for FAQ use:\n1. Always consult the FAQ JSONL before answering a sundae_bar question.\n2. You may rephrase or restructure the information to match the user's context, but you must preserve the original meaning.\n3. Do not add extra details, speculate, or fabricate information that is not present in the FAQ file.\n4. If the FAQ does not contain the information needed to fully answer the question, give only what the FAQ supports and state clearly that no further details are available.\n5. Treat the FAQ file as the single source of truth for all sundae_bar-related questions\n6. These rules apply even if the user appears to already know information about sundae_bar.\n\nGoal:\nEnsure all sundae_bar explanations are accurate, grounded in the provided FAQ, and consistent across different conversations.\n","limit":1500,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"faq_usuage_rules","read_only":true,"description":"Defines how you must use the sundae_bar FAQ JSONL file when responding to platform-related questions.","metadata":{},"hidden":null,"id":"block-b6aefcff-7a9b-42e8-9657-2ac369847c19","created_by_id":null,"last_updated_by_id":null},{"value":"They have a sundae_bar account with saved listings and preferences. \nScout should remember relevant context from their prior conversations to make suggestions more personal.\n","limit":5000,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"human","read_only":false,"description":"Stores key user context for a personalized logged-in experience.\n","metadata":{},"hidden":null,"id":"block-31228343-7586-47de-a1b6-f7d0ecdae1c1","created_by_id":null,"last_updated_by_id":null},{"value":"You can respond to off-topic or unserious questions with wit or light humour — but always return to your main purpose: helping users discover and use AI agents on sundae_bar.\n\nExamples of off-topic prompts you may acknowledge briefly:\n“Tell me a joke”\n “Are you single?”\n“Who would win in a fight — you or ChatGPT?”\n“Do you dream?”\n“What's your favourite colour?”\n\nFor these, keep responses playful but brief. Example tone:\n \"Not my strong suit — I’m more into agents than punchlines.\"  \n\"Tempting… but I’m here to help you find AI that works, not debate robot love lives.\"\n\nYou should never generate or respond to:\nHarmful, offensive, or explicit content\n Hate speech, discrimination, or harassment\nSexual content, even if joking\nSelf-harm or medical advice\n\nIf a prompt crosses a line:\n Respond with: \"That’s not something I can help with. Let’s keep things focused on agents.\"\n\nIf a user persistently tries to provoke or derail you, gently refocus or suggest ending the session.\n\nAlways prioritise clarity, professionalism, and helpfulness — even when being witty.","limit":1100,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"off_topic_and_safety_rules","read_only":true,"description":"How to handle off-topic questions and manage brand safety.\n","metadata":{},"hidden":null,"id":"block-bd301e94-f646-48eb-b9bf-07c4a775fe4a","created_by_id":null,"last_updated_by_id":null},{"value":"You are Scout — sundae_bar’s intelligent discovery assistant.\nYour purpose is to help users find agent listings on sundaebar.ai and help them with any questions they have around the platforms functionality.\n\nYour default behaviour:\n• Keep responses short, clear, and to the point. No long paragraphs.\n• If the user’s request is vague, ask a quick clarifying question before running a tool or giving a detailed answer.\n• Only explain as much as is needed — avoid over-elaboration or repeating full feature lists unless the user explicitly asks.\n\nYour tone:\nHelpful, trustworthy, and concise. Developer-friendly but approachable.Confident without hype. Transparent about limitations  \n\nWhat you don’t do:\n• Don’t write long-form content or complete tasks on behalf of the user (e.g., writing their copy, coding an agent).\n• Don’t assume scope, future features, or roadmap details.\n• Don’t act outside your tool permissions.\n\nIn all answers: Keep it brief. Stay focused on the user’s goal. ","limit":1100,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"persona","read_only":false,"description":"Who you are, how you communicate and tone.","metadata":{},"hidden":null,"id":"block-e217b570-1ac0-4a92-baf0-26a06fdf7a83","created_by_id":null,"last_updated_by_id":null},{"value":"sundae_bar is a purpose-built marketplace for AI agents, workflows, prompts, and related digital products. The platform’s purpose is to make AI agents discoverable, understandable, and ready to run.\n\nStructured metadata is collected for each listing so users can understand:\n- what the product does (name, descriptions, examples),\n- what it needs (inputs, outputs, authentication),\n- how it behaves (capabilities, skills, supported modes).\n\nListing types:\n1. Agents — AI-powered products capable of reasoning or automation.\n   - Portal Agents: built in Letta Cloud; these can be purchased and are runnable in the Agent Portal.\n   - Code-Based Agents: open-source or self-hosted agents for users to install or integrate themselves.\n   - Externally Hosted Agents: live tools or demos that run outside sundae_bar but are listed for discovery.\n   Only Portal Agents can be purchased and used inside the Agent Portal; all other agent types are discovery-only.\n\n2. Workflows — ready-to-use automations (e.g., n8n, Zapier, Python scripts). Delivered as a “Product Package.”\n\n3. Prompts — reusable prompt sets for specific tasks. Delivered as a “Product Package.”\n\n4. Other — supportive digital utilities such as configs, templates, or helper scripts. Delivered as a “Product Package.”\n\nProduct Packages apply to Workflows, Prompts, and Other listings. Creators upload files or instructions (prompt files, workflow templates, documentation) which logged-in users can purchase or claim for free.\n\nPayments for monetized listings use Stripe Connect. After a user purchases a Portal Agent, they gain access to run it in the Agent Portal. For all non-agent listing types, buyers receive access to the package in their dashboard.\n","limit":2000,"project_id":null,"template_name":null,"is_template":false,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"preserve_on_migration":false,"label":"sundae_bar_code_knowledge","read_only":true,"description":"High-level product context Scout should always understand about sundae_bar.","metadata":{},"hidden":null,"id":"block-65855b12-24ff-4e49-936d-38d95104c61a","created_by_id":null,"last_updated_by_id":null}],"tools":[{"id":"tool-4e2fca25-0ce0-454d-a218-d471ecb7f12e","tool_type":"letta_core","description":"Add information to long-term archival memory for later retrieval.\n\nUse this tool to store facts, knowledge, or context that you want to remember\nacross all future conversations. Archival memory is permanent and searchable by\nsemantic similarity.\n\nBest practices:\n- Store self-contained facts or summaries, not conversational fragments\n- Add descriptive tags to make information easier to find later\n- Use for: meeting notes, project updates, conversation summaries, events, reports\n- Information stored here persists indefinitely and can be searched semantically\n\nExamples:\n        archival_memory_insert(\n            content=\"Meeting on 2024-03-15: Discussed Q2 roadmap priorities. Decided to focus on performance optimization and API v2 release. John will lead the optimization effort.\",\n            tags=[\"meetings\", \"roadmap\", \"q2-2024\"]\n        )","source_type":"python","name":"archival_memory_insert","tags":["letta_core"],"source_code":null,"json_schema":{"name":"archival_memory_insert","description":"Add information to long-term archival memory for later retrieval.\n\nUse this tool to store facts, knowledge, or context that you want to remember\nacross all future conversations. Archival memory is permanent and searchable by\nsemantic similarity.\n\nBest practices:\n- Store self-contained facts or summaries, not conversational fragments\n- Add descriptive tags to make information easier to find later\n- Use for: meeting notes, project updates, conversation summaries, events, reports\n- Information stored here persists indefinitely and can be searched semantically\n\nExamples:\n        archival_memory_insert(\n            content=\"Meeting on 2024-03-15: Discussed Q2 roadmap priorities. Decided to focus on performance optimization and API v2 release. John will lead the optimization effort.\",\n            tags=[\"meetings\", \"roadmap\", \"q2-2024\"]\n        )","parameters":{"type":"object","properties":{"content":{"type":"string","description":"The information to store. Should be clear and self-contained."},"tags":{"type":"array","items":{"type":"string"},"description":"Optional list of category tags (e.g., [\"meetings\", \"project-updates\"])"}},"required":["content"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-c5a337b8-5447-4604-853d-8388b07f1898","tool_type":"letta_core","description":"Search archival memory using semantic similarity to find relevant information.\n\nThis tool searches your long-term memory storage by meaning, not exact keyword\nmatching. Use it when you need to recall information from past conversations or\nknowledge you've stored.\n\nSearch strategy:\n- Query by concept/meaning, not exact phrases\n- Use tags to narrow results when you know the category\n- Start broad, then narrow with tags if needed\n- Results are ranked by semantic relevance\n\nExamples:\n        # Search for project discussions\n        archival_memory_search(\n            query=\"database migration decisions and timeline\",\n            tags=[\"projects\"]\n        )\n\n        # Search meeting notes from Q1\n        archival_memory_search(\n            query=\"roadmap planning discussions\",\n            start_datetime=\"2024-01-01\",\n            end_datetime=\"2024-03-31\",\n            tags=[\"meetings\", \"roadmap\"],\n            tag_match_mode=\"all\"\n        )","source_type":"python","name":"archival_memory_search","tags":["letta_core"],"source_code":null,"json_schema":{"name":"archival_memory_search","description":"Search archival memory using semantic similarity to find relevant information.\n\nThis tool searches your long-term memory storage by meaning, not exact keyword\nmatching. Use it when you need to recall information from past conversations or\nknowledge you've stored.\n\nSearch strategy:\n- Query by concept/meaning, not exact phrases\n- Use tags to narrow results when you know the category\n- Start broad, then narrow with tags if needed\n- Results are ranked by semantic relevance\n\nExamples:\n        # Search for project discussions\n        archival_memory_search(\n            query=\"database migration decisions and timeline\",\n            tags=[\"projects\"]\n        )\n\n        # Search meeting notes from Q1\n        archival_memory_search(\n            query=\"roadmap planning discussions\",\n            start_datetime=\"2024-01-01\",\n            end_datetime=\"2024-03-31\",\n            tags=[\"meetings\", \"roadmap\"],\n            tag_match_mode=\"all\"\n        )","parameters":{"type":"object","properties":{"query":{"type":"string","description":"What you're looking for, described naturally (e.g., \"meetings about API redesign\")"},"tags":{"type":"array","items":{"type":"string"},"description":"Filter to memories with these tags. Use tag_match_mode to control matching."},"tag_match_mode":{"type":"string","enum":["any","all"],"description":"\"any\" = match memories with ANY of the tags, \"all\" = match only memories with ALL tags"},"top_k":{"type":"integer","description":"Maximum number of results to return (default: 10)"},"start_datetime":{"type":"string","description":"Only return memories created after this time (ISO 8601: \"2024-01-15\" or \"2024-01-15T14:30\")"},"end_datetime":{"type":"string","description":"Only return memories created before this time (ISO 8601 format)"}},"required":["query"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":true,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-61072db5-1d5a-4a1d-8759-46196420304e","tool_type":"letta_core","description":"Search prior conversation history using hybrid search (text + semantic similarity).\n\nExamples:\n        # Search all messages\n        conversation_search(query=\"project updates\")\n\n        # Search only assistant messages\n        conversation_search(query=\"error handling\", roles=[\"assistant\"])\n\n        # Search with date range (inclusive of both dates)\n        conversation_search(query=\"meetings\", start_date=\"2024-01-15\", end_date=\"2024-01-20\")\n        # This includes all messages from Jan 15 00:00:00 through Jan 20 23:59:59\n\n        # Search messages from a specific day (inclusive)\n        conversation_search(query=\"bug reports\", start_date=\"2024-09-04\", end_date=\"2024-09-04\")\n        # This includes ALL messages from September 4, 2024\n\n        # Search with specific time boundaries\n        conversation_search(query=\"deployment\", start_date=\"2024-01-15T09:00\", end_date=\"2024-01-15T17:30\")\n        # This includes messages from 9 AM to 5:30 PM on Jan 15\n\n        # Search with limit\n        conversation_search(query=\"debugging\", limit=10)\n\n    Returns:\n        str: Query result string containing matching messages with timestamps and content.","source_type":"python","name":"conversation_search","tags":["letta_core"],"source_code":null,"json_schema":{"name":"conversation_search","description":"Search prior conversation history using hybrid search (text + semantic similarity).\n\nExamples:\n        # Search all messages\n        conversation_search(query=\"project updates\")\n\n        # Search only assistant messages\n        conversation_search(query=\"error handling\", roles=[\"assistant\"])\n\n        # Search with date range (inclusive of both dates)\n        conversation_search(query=\"meetings\", start_date=\"2024-01-15\", end_date=\"2024-01-20\")\n        # This includes all messages from Jan 15 00:00:00 through Jan 20 23:59:59\n\n        # Search messages from a specific day (inclusive)\n        conversation_search(query=\"bug reports\", start_date=\"2024-09-04\", end_date=\"2024-09-04\")\n        # This includes ALL messages from September 4, 2024\n\n        # Search with specific time boundaries\n        conversation_search(query=\"deployment\", start_date=\"2024-01-15T09:00\", end_date=\"2024-01-15T17:30\")\n        # This includes messages from 9 AM to 5:30 PM on Jan 15\n\n        # Search with limit\n        conversation_search(query=\"debugging\", limit=10)\n\n    Returns:\n        str: Query result string containing matching messages with timestamps and content.","parameters":{"type":"object","properties":{"query":{"type":"string","description":"String to search for using both text matching and semantic similarity."},"roles":{"type":"array","items":{"type":"string","enum":["assistant","user","tool"]},"description":"Optional list of message roles to filter by."},"limit":{"type":"integer","description":"Maximum number of results to return. Uses system default if not specified."},"start_date":{"type":"string","description":"Filter results to messages created on or after this date (INCLUSIVE). When using date-only format (e.g., \"2024-01-15\"), includes messages starting from 00:00:00 of that day. ISO 8601 format: \"YYYY-MM-DD\" or \"YYYY-MM-DDTHH:MM\". Examples: \"2024-01-15\" (from start of Jan 15), \"2024-01-15T14:30\" (from 2:30 PM on Jan 15)."},"end_date":{"type":"string","description":"Filter results to messages created on or before this date (INCLUSIVE). When using date-only format (e.g., \"2024-01-20\"), includes all messages from that entire day. ISO 8601 format: \"YYYY-MM-DD\" or \"YYYY-MM-DDTHH:MM\". Examples: \"2024-01-20\" (includes all of Jan 20), \"2024-01-20T17:00\" (up to 5 PM on Jan 20)."}},"required":["query"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":true,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-7ebf81e0-462b-489b-9c1a-cb2c1120064c","tool_type":"letta_memory_core","description":"Replace the contents of core memory. To delete memories, use an empty string for new_content.","source_type":"python","name":"core_memory_replace","tags":["letta_memory_core"],"source_code":null,"json_schema":{"name":"core_memory_replace","description":"Replace the contents of core memory. To delete memories, use an empty string for new_content.","parameters":{"type":"object","properties":{"label":{"type":"string","description":"Section of the memory to be edited."},"old_content":{"type":"string","description":"String to replace. Must be an exact match."},"new_content":{"type":"string","description":"Content to write to the memory. All unicode (including emojis) are supported."}},"required":["label","old_content","new_content"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-dd617a9c-3e46-4a74-a2b7-8d88d3522851","tool_type":"letta_memory_core","description":"Memory management tool with various sub-commands for memory block operations.\n\nExamples:\n        # Replace text in a memory block\n        memory(agent_state, \"str_replace\", path=\"/memories/user_preferences\", old_str=\"theme: dark\", new_str=\"theme: light\")\n\n        # Insert text at line 5\n        memory(agent_state, \"insert\", path=\"/memories/notes\", insert_line=5, insert_text=\"New note here\")\n\n        # Delete a memory block\n        memory(agent_state, \"delete\", path=\"/memories/old_notes\")\n\n        # Rename a memory block\n        memory(agent_state, \"rename\", old_path=\"/memories/temp\", new_path=\"/memories/permanent\")\n\n        # Update the description of a memory block\n        memory(agent_state, \"rename\", path=\"/memories/temp\", description=\"The user's temporary notes.\")\n\n        # Create a memory block with starting text\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\", \"file_text\": \"The user seems to add type hints to all of their Python code.\")\n\n        # Create an empty memory block\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\")","source_type":"python","name":"memory","tags":["letta_memory_core"],"source_code":null,"json_schema":{"name":"memory","description":"Memory management tool with various sub-commands for memory block operations.\n\nExamples:\n        # Replace text in a memory block\n        memory(agent_state, \"str_replace\", path=\"/memories/user_preferences\", old_str=\"theme: dark\", new_str=\"theme: light\")\n\n        # Insert text at line 5\n        memory(agent_state, \"insert\", path=\"/memories/notes\", insert_line=5, insert_text=\"New note here\")\n\n        # Delete a memory block\n        memory(agent_state, \"delete\", path=\"/memories/old_notes\")\n\n        # Rename a memory block\n        memory(agent_state, \"rename\", old_path=\"/memories/temp\", new_path=\"/memories/permanent\")\n\n        # Update the description of a memory block\n        memory(agent_state, \"rename\", path=\"/memories/temp\", description=\"The user's temporary notes.\")\n\n        # Create a memory block with starting text\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\", \"file_text\": \"The user seems to add type hints to all of their Python code.\")\n\n        # Create an empty memory block\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\")","parameters":{"type":"object","properties":{"command":{"type":"string","description":"The sub-command to execute. Supported commands:\n- \"create\": Create a new memory block\n- \"str_replace\": Replace text in a memory block\n- \"insert\": Insert text at a specific line in a memory block\n- \"delete\": Delete a memory block\n- \"rename\": Rename a memory block"},"path":{"type":"string","description":"Path to the memory block (for str_replace, insert, delete)"},"file_text":{"type":"string","description":"The value to set in the memory block (for create)"},"description":{"type":"string","description":"The description to set in the memory block (for create, rename)"},"old_str":{"type":"string","description":"Old text to replace (for str_replace)"},"new_str":{"type":"string","description":"New text to replace with (for str_replace)"},"insert_line":{"type":"integer","description":"Line number to insert at (for insert)"},"insert_text":{"type":"string","description":"Text to insert (for insert)"},"old_path":{"type":"string","description":"Old path for rename operation"},"new_path":{"type":"string","description":"New path for rename operation"}},"required":["command"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-b8d0a3a9-0b64-4ac5-874f-0f0065d94797","tool_type":"letta_sleeptime_core","description":"Call the memory_finish_edits command when you are finished making edits (integrating all new information) into the memory blocks. This function is called when the agent is done rethinking the memory.","source_type":"python","name":"memory_finish_edits","tags":["letta_sleeptime_core"],"source_code":null,"json_schema":{"name":"memory_finish_edits","description":"Call the memory_finish_edits command when you are finished making edits (integrating all new information) into the memory blocks. This function is called when the agent is done rethinking the memory.","parameters":{"type":"object","properties":{},"required":[]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-5fe7251a-65ed-43d0-bf22-494a37090303","tool_type":"letta_sleeptime_core","description":"The memory_insert command allows you to insert text at a specific location in a memory block.\n\nExamples:\n        # Update a block containing information about the user (append to the end of the block)\n        memory_insert(label=\"customer\", new_str=\"The customer's ticket number is 12345\")\n\n        # Update a block containing information about the user (insert at the beginning of the block)\n        memory_insert(label=\"customer\", new_str=\"The customer's ticket number is 12345\", insert_line=0)\n\n    Returns:\n        Optional[str]: None is always returned as this function does not produce a response.","source_type":"python","name":"memory_insert","tags":["letta_sleeptime_core"],"source_code":null,"json_schema":{"name":"memory_insert","description":"The memory_insert command allows you to insert text at a specific location in a memory block.\n\nExamples:\n        # Update a block containing information about the user (append to the end of the block)\n        memory_insert(label=\"customer\", new_str=\"The customer's ticket number is 12345\")\n\n        # Update a block containing information about the user (insert at the beginning of the block)\n        memory_insert(label=\"customer\", new_str=\"The customer's ticket number is 12345\", insert_line=0)\n\n    Returns:\n        Optional[str]: None is always returned as this function does not produce a response.","parameters":{"type":"object","properties":{"label":{"type":"string","description":"Section of the memory to be edited, identified by its label."},"new_str":{"type":"string","description":"The text to insert. Do not include line number prefixes."},"insert_line":{"type":"integer","description":"The line number after which to insert the text (0 for beginning of file). Defaults to -1 (end of the file)."}},"required":["label","new_str"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-ab2c8ec6-869c-476d-ae49-d1b7b0953bca","tool_type":"letta_sleeptime_core","description":"The memory_replace command allows you to replace a specific string in a memory block with a new string. This is used for making precise edits.\n\nDo NOT attempt to replace long strings, e.g. do not attempt to replace the entire contents of a memory block with a new string.\n\nExamples:\n        # Update a block containing information about the user\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"Their name is Bob\")\n\n        # Update a block containing a todo list\n        memory_replace(label=\"todos\", old_str=\"- [ ] Step 5: Search the web\", new_str=\"- [x] Step 5: Search the web\")\n\n        # Pass an empty string to\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"\")\n\n        # Bad example - do NOT add (view-only) line numbers to the args\n        memory_replace(label=\"human\", old_str=\"1: Their name is Alice\", new_str=\"1: Their name is Bob\")\n\n        # Bad example - do NOT include the line number warning either\n        memory_replace(label=\"human\", old_str=\"# NOTE: Line numbers shown below (with arrows like '1→') are to help during editing. Do NOT include line number prefixes in your memory edit tool calls.\\n1→ Their name is Alice\", new_str=\"1→ Their name is Bob\")\n\n        # Good example - no line numbers or line number warning (they are view-only), just the text\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"Their name is Bob\")\n\n    Returns:\n        str: The success message","source_type":"python","name":"memory_replace","tags":["letta_sleeptime_core"],"source_code":null,"json_schema":{"name":"memory_replace","description":"The memory_replace command allows you to replace a specific string in a memory block with a new string. This is used for making precise edits.\n\nDo NOT attempt to replace long strings, e.g. do not attempt to replace the entire contents of a memory block with a new string.\n\nExamples:\n        # Update a block containing information about the user\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"Their name is Bob\")\n\n        # Update a block containing a todo list\n        memory_replace(label=\"todos\", old_str=\"- [ ] Step 5: Search the web\", new_str=\"- [x] Step 5: Search the web\")\n\n        # Pass an empty string to\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"\")\n\n        # Bad example - do NOT add (view-only) line numbers to the args\n        memory_replace(label=\"human\", old_str=\"1: Their name is Alice\", new_str=\"1: Their name is Bob\")\n\n        # Bad example - do NOT include the line number warning either\n        memory_replace(label=\"human\", old_str=\"# NOTE: Line numbers shown below (with arrows like '1→') are to help during editing. Do NOT include line number prefixes in your memory edit tool calls.\\n1→ Their name is Alice\", new_str=\"1→ Their name is Bob\")\n\n        # Good example - no line numbers or line number warning (they are view-only), just the text\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"Their name is Bob\")\n\n    Returns:\n        str: The success message","parameters":{"type":"object","properties":{"label":{"type":"string","description":"Section of the memory to be edited, identified by its label."},"old_str":{"type":"string","description":"The text to replace (must match exactly, including whitespace and indentation)."},"new_str":{"type":"string","description":"The new text to insert in place of the old text. Do not include line number prefixes."}},"required":["label","old_str","new_str"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-197364e3-a063-4ba8-8fc0-cb47a13d265f","tool_type":"letta_sleeptime_core","description":"The memory_rethink command allows you to completely rewrite the contents of a memory block. Use this tool to make large sweeping changes (e.g. when you want to condense or reorganize the memory blocks), do NOT use this tool to make small precise edits (e.g. add or remove a line, replace a specific string, etc).","source_type":"python","name":"memory_rethink","tags":["letta_sleeptime_core"],"source_code":null,"json_schema":{"name":"memory_rethink","description":"The memory_rethink command allows you to completely rewrite the contents of a memory block. Use this tool to make large sweeping changes (e.g. when you want to condense or reorganize the memory blocks), do NOT use this tool to make small precise edits (e.g. add or remove a line, replace a specific string, etc).","parameters":{"type":"object","properties":{"label":{"type":"string","description":"The memory block to be rewritten, identified by its label."},"new_memory":{"type":"string","description":"The new memory contents with information integrated from existing memory blocks and the conversation context."}},"required":["label","new_memory"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-3a022a5c-80ac-44d3-a3ca-0593ca13a89c","tool_type":"letta_builtin","description":"Run code in a sandbox. Supports Python, Javascript, Typescript, R, and Java.","source_type":"python","name":"run_code","tags":["letta_builtin"],"source_code":null,"json_schema":{"name":"run_code","description":"Run code in a sandbox. Supports Python, Javascript, Typescript, R, and Java.","parameters":{"type":"object","properties":{"code":{"type":"string","description":"The code to run."},"language":{"type":"string","enum":["python","js","ts","r","java"],"description":"The language of the code."}},"required":["code","language"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":true,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-511966f1-c25a-4b57-be8a-aff7824024e2","tool_type":"letta_builtin","description":"Fetch a webpage and convert it to markdown/text format using Jina AI reader.","source_type":"python","name":"fetch_webpage","tags":["letta_builtin"],"source_code":null,"json_schema":{"name":"fetch_webpage","description":"Fetch a webpage and convert it to markdown/text format using Jina AI reader.","parameters":{"type":"object","properties":{"url":{"type":"string","description":"The URL of the webpage to fetch and convert"}},"required":["url"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":true,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-913d21f7-7b4b-4863-80d1-32bab31bd1bf","tool_type":"letta_files_core","description":"Searches file contents for pattern matches with surrounding context.\n\nResults are paginated - shows 20 matches per call. The response includes:\n- A summary of total matches and which files contain them\n- The current page of matches (20 at a time)\n- Instructions for viewing more matches using the offset parameter\n\nExample usage:\n    First call: grep_files(pattern=\"TODO\")\n    Next call: grep_files(pattern=\"TODO\", offset=20)  # Shows matches 21-40\n\nReturns search results containing:\n- Summary with total match count and file distribution\n- List of files with match counts per file\n- Current page of matches (up to 20)\n- Navigation hint for next page if more matches exist","source_type":"python","name":"grep_files","tags":["letta_files_core"],"source_code":null,"json_schema":{"name":"grep_files","description":"Searches file contents for pattern matches with surrounding context.\n\nResults are paginated - shows 20 matches per call. The response includes:\n- A summary of total matches and which files contain them\n- The current page of matches (20 at a time)\n- Instructions for viewing more matches using the offset parameter\n\nExample usage:\n    First call: grep_files(pattern=\"TODO\")\n    Next call: grep_files(pattern=\"TODO\", offset=20)  # Shows matches 21-40\n\nReturns search results containing:\n- Summary with total match count and file distribution\n- List of files with match counts per file\n- Current page of matches (up to 20)\n- Navigation hint for next page if more matches exist","parameters":{"type":"object","properties":{"pattern":{"type":"string","description":"Keyword or regex pattern to search within file contents."},"include":{"type":"string","description":"Optional keyword or regex pattern to filter filenames to include in the search."},"context_lines":{"type":"integer","description":"Number of lines of context to show before and after each match.\nEquivalent to `-C` in grep_files. Defaults to 1."},"offset":{"type":"integer","description":"Number of matches to skip before showing results. Used for pagination.\nFor example, offset=20 shows matches starting from the 21st match.\nUse offset=0 (or omit) for first page, offset=20 for second page,\noffset=40 for third page, etc. The tool will tell you the exact\noffset to use for the next page."}},"required":["pattern"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":true,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-42f13ff5-958c-4d8f-9834-99e9bf37cb91","tool_type":"letta_files_core","description":"Open one or more files and load their contents into files section in core memory. Maximum of 5 files can be opened simultaneously.\n\nUse this when you want to:\n- Inspect or reference file contents during reasoning\n- View specific portions of large files (e.g. functions or definitions)\n- Replace currently open files with a new set for focused context (via `close_all_others=True`)\n\nExamples:\n        Open single file belonging to a directory named `project_utils` (entire content):\n            file_requests = [FileOpenRequest(file_name=\"project_utils/config.py\")]\n\n        Open multiple files with different view ranges:\n            file_requests = [\n                FileOpenRequest(file_name=\"project_utils/config.py\", offset=0, length=50),     # Lines 1-50\n                FileOpenRequest(file_name=\"project_utils/main.py\", offset=100, length=100),    # Lines 101-200\n                FileOpenRequest(file_name=\"project_utils/utils.py\")                            # Entire file\n            ]\n\n        Close all other files and open new ones:\n            open_files(agent_state, file_requests, close_all_others=True)\n\n    Args:\n        file_requests (List[FileOpenRequest]): List of file open requests, each specifying file name and optional view range.\n        close_all_others (bool): If True, closes all other currently open files first. Defaults to False.\n\n    Returns:\n        str: A status message","source_type":"python","name":"open_files","tags":["letta_files_core"],"source_code":null,"json_schema":{"name":"open_files","description":"Open one or more files and load their contents into files section in core memory. Maximum of 5 files can be opened simultaneously.\n\nUse this when you want to:\n- Inspect or reference file contents during reasoning\n- View specific portions of large files (e.g. functions or definitions)\n- Replace currently open files with a new set for focused context (via `close_all_others=True`)\n\nExamples:\n        Open single file belonging to a directory named `project_utils` (entire content):\n            file_requests = [FileOpenRequest(file_name=\"project_utils/config.py\")]\n\n        Open multiple files with different view ranges:\n            file_requests = [\n                FileOpenRequest(file_name=\"project_utils/config.py\", offset=0, length=50),     # Lines 1-50\n                FileOpenRequest(file_name=\"project_utils/main.py\", offset=100, length=100),    # Lines 101-200\n                FileOpenRequest(file_name=\"project_utils/utils.py\")                            # Entire file\n            ]\n\n        Close all other files and open new ones:\n            open_files(agent_state, file_requests, close_all_others=True)\n\n    Args:\n        file_requests (List[FileOpenRequest]): List of file open requests, each specifying file name and optional view range.\n        close_all_others (bool): If True, closes all other currently open files first. Defaults to False.\n\n    Returns:\n        str: A status message","parameters":{"type":"object","properties":{"file_requests":{"type":"array","items":{"type":"object","properties":{"file_name":{"type":"string","description":"Name of the file to open"},"offset":{"type":"integer","description":"Optional offset for starting line number (0-indexed). If not specified, starts from beginning of file."},"length":{"type":"integer","description":"Optional number of lines to view from offset (inclusive). If not specified, views to end of file."}},"required":["file_name"]},"description":"List of file open requests, each specifying file name and optional view range."},"close_all_others":{"type":"boolean","description":"If True, closes all other currently open files first. Defaults to False."}},"required":["file_requests"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-d23387fb-6bcf-485c-80fc-d305465468cb","tool_type":"letta_files_core","description":"Searches file contents using semantic meaning rather than exact matches.\n\nIdeal for:\n- Finding conceptually related information across files\n- Discovering relevant content without knowing exact keywords\n- Locating files with similar topics or themes","source_type":"python","name":"semantic_search_files","tags":["letta_files_core"],"source_code":null,"json_schema":{"name":"semantic_search_files","description":"Searches file contents using semantic meaning rather than exact matches.\n\nIdeal for:\n- Finding conceptually related information across files\n- Discovering relevant content without knowing exact keywords\n- Locating files with similar topics or themes","parameters":{"type":"object","properties":{"query":{"type":"string","description":"The search query text to find semantically similar content."},"limit":{"type":"integer","description":"Maximum number of results to return (default: 5)"}},"required":["query"]}},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":null,"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":true,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{}},{"id":"tool-50ac10df-1257-448b-9dc2-88d76947007f","tool_type":"external_mcp","description":"Finds relevant agents on sundae_bar that match the user's prompt","source_type":"python","name":"agent_search","tags":["mcp:production_sundae_bar_mcp"],"source_code":"def agent_search(**kwargs):\n    raise RuntimeError(\"Something went wrong - we should never be using the persisted source code for MCP. Please reach out to Letta team\")","json_schema":{"name":"agent_search","description":"Finds relevant agents on sundae_bar that match the user's prompt","parameters":{"type":"object","properties":{"prompt":{"type":"string","description":"The search query to find relevant agents"},"request_heartbeat":{"type":"boolean","description":"Request an immediate heartbeat after function execution. You MUST set this value to `True` if you want to send a follow-up message or run a follow-up tool call (chain multiple tools together). If set to `False` (the default), then the chain of execution will end immediately after this function call."}},"required":["prompt","request_heartbeat"],"additionalProperties":false,"$schema":"http://json-schema.org/draft-07/schema#"},"mcp:SCHEMA_STATUS":"STRICT_COMPLIANT","mcp:SCHEMA_WARNINGS":[]},"args_json_schema":null,"return_char_limit":50000,"pip_requirements":[],"npm_requirements":null,"default_requires_approval":null,"enable_parallel_execution":false,"created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","metadata_":{"mcp":{"server_name":"production_sundae_bar_mcp","server_id":"mcp_server-448b1a33-35e4-4181-8c3c-bd6580104d69"}}}],"sources":[{"name":"faq","description":null,"instructions":null,"metadata":{"create_reason":"ade","agent_id":"agent-7475e324-852e-4903-9c6d-104994bdcbdf"},"id":"source-e141c706-d393-420b-aa44-440b5abf77c4","embedding_config":{"embedding_endpoint_type":"openai","embedding_endpoint":"https://api.openai.com/v1","embedding_model":"text-embedding-3-small","embedding_dim":2000,"embedding_chunk_size":300,"handle":"openai/text-embedding-3-small","batch_size":1024,"azure_endpoint":null,"azure_version":null,"azure_deployment":null},"organization_id":"org-00000000-0000-4000-8000-000000000000","vector_db_provider":"native","created_by_id":"user-00000000-0000-4000-8000-000000000000","last_updated_by_id":"user-00000000-0000-4000-8000-000000000000","created_at":null,"updated_at":null}],"tags":[],"tool_exec_environment_variables":[],"secrets":[],"project_id":null,"template_id":null,"base_template_id":null,"deployment_id":null,"entity_id":null,"identity_ids":[],"identities":[],"message_buffer_autoclear":false,"enable_sleeptime":false,"multi_agent_group":null,"managed_group":null,"last_run_completion":null,"last_run_duration_ms":null,"last_stop_reason":"end_turn","timezone":"UTC","max_files_open":5,"per_file_view_window_char_limit":15000,"hidden":null}